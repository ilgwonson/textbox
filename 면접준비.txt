● 웹싸이트 최적화
    ㄱ. 페이지가 로드 되면서 렌더트리가 생성될때 css가 필요 하므로 css 를 헤더위에 넣고, script를 body 안 최 하단에 넣어서 스크립트 로딩으로 인한 페이지 로딩 지연을 줄인다.
    ㄴ. 렌더링 엔진(html + css layout javascript dom binding)
    ㄷ. translate,opacity,scale,rotate등의 변경은 composite layer 단계만 다시 수정하므로 속도가 빠르고 하드웨어 가속을 사용할수 있음
    ㄹ. 사용자에게 화면을 보여 주기 전에 렌더 트리를 생성해야 하는데, 이때 스타일시트 파일이 반드시 필요하다. 스타일시트 파일을 최대한 빨리 다운로드해야 하는 이유다.
    ㅁ. sprite이미지 사용하기(하지만 전 회사에서는 사용안하기도 했음 디자이너 편의를 위해)
    ㅂ. grunt와 inject를 사용하여 js파일과 css 파일을 minify한후 하나의 파일로 inject하였슴.
    ㅅ. 실험적으로 minifest와 구글에서 만든 amp를 사용해보았다.
    ㅇ. 반복문의 조건식에 length를 변수에 저장
    ㅈ. 스코프 체인에서 탐색을 줄이기 위해 외부 전역 변수나 상위 스코프 변수를 변수에 저장
    ㅇ. 스크립트로 dom을 수정할경우 렌더링과정이 반복되니 최종본이 나오기 전까지 display:none이나 노드를 복사하여 수정하여서 기존꺼를 대체 하는 식으로 한다.
    ㅈ. 이벤트 위임 부모에게 이벤트를 줘서 자식들을 처리함
    ㅊ. CDN(Content Delivery Network)은 접속하는 사용자의 위치에 따라서 응답이 빠른 서버로 접속하여 필요한 파일들을 호출하는 것을 말한다.

● 자바스크립트 최적화
    - 여러번 접근하게 되는 스코프체인 변수는 지역변수에 저장
    - 여러번 접근하게 되는 dom객체는 지역변수에 저장
    - 이벤트 위임
    - with 구문 사용하지 않기
    - 고정된 변경일 경우 style 대신 클래스로 변경하기
    - 배열은 for in으로 돌리지 않기
    - length 프로퍼티 변수에 저장해서 for문 돌리기
    - new 생성자보다는 리터럴 사용하기
    - 리플로를 줄이기위해 수정되는 dom display:none시키고 수정하던지 아니면 돔 복사 고치고 replace
    - 리플로 발생하는 작업끼리 그루핑하기

● 이벤트 전달
    - e.preventDefault() 기본이벤트 막기
    - e.stopPropagation() 이벤트가 버블링 되는거 막기
    - return false; 위에 두개다 실행되고 타겟에 다른 이벤트들도 실행되지 않는다.

● reflow 발생 원인
    - 윈도우 Resize
    - font변경
    - style 추가나 삭제
    - element 추가나 삭제, 위치 변경, 크기 변경
    - reflow가 발생하면 render tree가 재구축되면 repaint가 일어난다.

● 웹시스템 동작흐름 파악
    - DNS서버로 가서 ip주소 얻은후 연결 http 요청메시지 웹서버에 보내고 웹서버는 response http메시지를 보냄

● css 에니메이션 최적화
    - https://www.html5rocks.com/ko/tutorials/speed/high-performance-animations/

● 랜더링 과정(랜더링 엔진)
    - 로딩 : 리소스 스트림를 읽어온다.
    - 파싱 : html을 파싱하여 dom 트리를 만든다.
    - css를 이용하여 rendering 트리를 만든다. display :None은 안함
     객체의 위치와 크기로 레이아웃을 잡고 마지막으로 페인팅 과정을 통해 렌더링이 마무리 된다.


● Agile 방식
    - http://skmagic.tistory.com/entry/%EC%95%A0%EC%9E%90%EC%9D%BC-AGILE-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EB%B2%95
    - http://blog.rightbrain.co.kr/?p=5810

● RESTful API에 대해 설명
     URI는 정보의 자원을 표현해야 한다.
     자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.
     무상태성 : 작업에 상태정보를 따로 저장하지 않는다.
    - http://meetup.toast.com/posts/92

● angular 동작방법
    - Angular execution context 를 통해 data-binding, exception 처리, 프로퍼티 변경 감시 등
    - http://mobicon.tistory.com/270

● 의존성주입입
    구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의

● CommonJS, AMD (Asyncronouse Module Definition)

● 디자인 패턴
    - https://joshua1988.github.io/web_dev/javascript-pattern-design/
    - http://boxersb.github.io/javascript/2010/04/01/observer-pattern-of-javascript/

● 자료구조
    - 연결리스트, 배열, 해시테이블
    - 스택, 큐, 덱, 트리, 그래프

● 정렬
    - http://hsp1116.tistory.com/33
    - 선택 정렬
        For(var i=0;i<arr.length;i++){
            for(var j=0;j<arr.length;j++){
                if(arr[i]>arr[j]) swap(arr[i],arr[j]);
            }
        }
    - 삽입 정렬
        For(var i=1;i<arr.length;i++){
            var key = arr[i], j = i-1;
            while(j>=0 && key < v[j]){
                arr[j+1] = arr[j];
                j--;
            }
            arr[j+1] = key;
        }
     - 버블 정렬
        For(var i=0;i<arr.length;i++){
            for(var j=1;j<arr.length;j++){
                if(arr[j-1]>arr[j]) swap(arr[j-1],arr[j]);
            }
        }
      - 합병정렬

● 정렬속도 비교
    http://wonjayk.tistory.com/225
    정렬이 거의 되어있는 배열일 경우에는 삽입정렬이 속도가 제일 빠르다.

● 부동소수점의 한계
    부동소수점이란? 소수점의 위치를 정해놓지 않고 지수를 통해 위치 표현하는 것
    소수점 및 10진수를 2진수로 표현하는데에 한계
    0 * 1/2 1*1/4 1*1/8

● 리팩토링에 관한 질문
    리랙토링 하다(Refactoring) - 일련의 리펙토링을 적용하여 겉으로 보이는 동작의 변화 없이 소프트웨어 구조를 바꾸다.
    첫째 리팩토링의 목적은 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것이다

● 검색
    순차검색 이분검색,이진트리검색,해쉬(키와 밸류값으로 구분-키값을 주면 데이터의 주소로 맵핑)

● 자바스크립트 장단점
    - 소스가 노출되어 그대로 복사 및 사용 가능
    - 클로저 같은 경우 따로 매개변수를 넣지 않아도 변수에 접근가능해서 좋다. 하지만 독립성이 떨어져 재활용이 어렵다.
    - 변수 선언 통일화(안좋을수도)
    - 멀티쓰레드 지원 안함
    - 인터프리터 언어라 속도 느림
    - 객체 선언 및 확장 용이
    - 자동형변환
    - 상속방법이 불편

● 인터프리트
    한줄씩 기계어로 해석하여 실행(속도가 느림)

● 실행 컨텍스트
    전역컨텍스트가 생기고 그다음에 실행컨텍스트가 스택으로 쌓인다.
    실행컨텍스트는 변수객체, 스코프체인, this객체를 가진다.
    스코프체인에는 변수가 스택으로 쌓인다.
    http://insanehong.kr/post/javascript-scope/

● 자바스크립트 보안
    - 스크립트 도용 못하게 하기
        자바스크립트 minify와 난독화(google closure compiler)
    - SourceMaps은 압축된 코드와 압축 전의 코드를 Base64 기반으로 매핑한 데이터를 말한다.
    - javascript를 암호화 하기
    - ssl : https로 웹서버와 웹브라우저간 인증서와 키를 동해 암호화해서 통신한다.
    - 자바스크립트 암호화 Packer JavaScript
    - 동일 출처 정책
        iframe나 다른창 등은 같은 출처의 문서일 경우에만 window와 document에 접근할수 있다.(서브도메인이나 포트만 달라도 안됨,http,https)
    - Cross-Origin Resource Sharing (CORS) : 도메인이 다른 경우에도 ajax가 가능하다.(XMLHttpRequest와 같은) API 컨테이너 내에서 CORS를 사용
    - 플러그인이나 activeX등을 통해 자바스크립트로 주요 기능들이 노출 될수 있다.
    - XSS URL이나 input,textarea로 script태그나 HTML태그를 집어넣는 보안문제 , replace를 통해 태그를 없애준다.

● 함수 선언방시에 따른 차이 - 변수로 선언하면 메모리에서 삭제가 가능
    변수로 설정할 경우 필요에 따라 할당하고 해제 할수 있다.
    변수로 설정하면 변수와 같으 호이스팅 방식으로

● 호이스팅
    선언문은 항시 자바스크립트 엔진 구동시 가장 최우선으로 해석(할당은 되지 않는다.)

● 유니코드
    세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준

● ASCII
    영문 알파벳을 사용하는 대표적인 문자 인코딩(키마다 고유의 숫자값이 있음)

● 프로토타입 심화
    프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만든다.
    생성된 객체의 프로토 타입 속성을 변경하면 재정의되 덮어쓴다. 프로퍼티 속성은 hasownproperty false지만 재정의 된후에는 트루로 바뀐다.
    객체에는 자동적으로 프로토타입이 연결된다.
    함수일 경우에는 함수의 프로토타입 프로퍼티에 프로퍼티 객체가 연결되고, 프로토타입객체의 constructor는 함수를 가르킨다.
    new 함수 연산자를 통해 객체가 만들어 지면 proto 속성의 숨은링크로 프로토타입이 연결된다.
    프로토타입에도 스코프 체인이 있다. 프로토타입을따라 변수를 검색한다.
    http://www.nextree.co.kr/p7323/

● eval의 문제점
    디버깅이 쉽지 않다.
    속도가 느리다 : 코드가 두번 interpret 된다. 스트링 -> 함수, 함수->기계어
    사용자 입력을 개발자가 다루고 eval() 에 의해 이게 실행 된다면 위험하다고 할수있다. xss보안

● 희소배열
    행렬의 값이 대부분 0인 경우를 가리키는 표현

● 식별자 표현문 표현식 용어 정리
    식별자 :  변수, 자료형, 서브루틴 등을 가리키는 토큰이다.
    표현문 : 부수 효과가 있는 표현식, 세미콜론으로 끝남
    표현식 : 값을 나타내는

● 자바스크립트 try catch 잘 안쓰는 이유
    ajax의 에러 이벤트가 있다.
    이벤트형 프로그래임라 에러가 나도 그부분만 안되지 다른 부분이 될경우가 많아서

● 단위테스트
    프로그램을 작은 단위로 쪼개서 각 단위가 정확하게 동작하는지 검사하고 이를 통해 문제 발생 시 정확하게 어느 부분이 잘못되었는지를 재빨리 확인할 수 있게 해준다.
    리펙토링에 좋다.
    Qunit + Karma

● generic
    형식 매개 변수라고 칭하기도 합니다.
    매개변수의 타입형을 융통성 있게 바꿀수 있다. <T>

● instanceOf 프레임(새창, iframe)이 여러개일때 오류 발생 가능성 있음
    프레임이 다르면 window나 같은 소스로 선언된 객체더라도 엄연히 다른 객체이다.
    그래서 원하는 값이 안나온다.

● 자바스크립트 네임스페이스
    모듈간의 서로간 소스 충돌을 막기 위해서
    하나의 변수에 객체로 네임스페이스를 설정한다. 예로 jquery, $

● 파셜어플리케이션, 커링
    자바스크립트에는 bind를 통해 매개변수를 미리 맵핑하는식으로 하는것을 파셜어플리케이션이라고 한다.
    함수형 프로그래밍중 하나의 기법, 함수를 재사용하는데 유용하게 쓰일 수 있는 기법이다. (작은 기능으로 여러개 쪼개놓았기 때문)
    커링은 함수 하나가 n개의 인자를 받는 과정을 n개의 함수로 각각의 인자를 받도록 하는 것이다.
    부분적으로 적용된 함수를 체인으로 계속 생성해 결과적으로 값을 처리하도록 하는 것이 그 본질이다.
    curried( 1 )( 2 )( 3 );
    var arity = fn.length;
      return (function resolver() {
        var memory = Array.prototype.slice.call( arguments );
      }());



● 함수형 프로그래밍
    모든 과정을 함수로 묶고 작은 기능으로 세분화하여
    함수를 통해 코드를 작성하는일
    상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.
    클로저 대신 매개변수를 통해 작업

● FOUC
    FOUC(Flash Of Unstyled Content)는 외부의 CSS가 불러오기 전에 잠시 스타일이 적용되지 않은 웹 페이지가 나타나는 현상이다.(화면깜박임)
    원인
    웹 페이지들은 종종 프린터와 무선 장치를 위한 CSS 규칙으로 브라우저 화면 이외의 다른 미디어에 대한 스타일 참조를 포함한다.
    웹 페이지는 @import로 스타일 파일을 가져오고, 다른 CSS를 참조할 수 있다.
    온라인 광고와 동영상과 검색 엔진같은 다른 곳에서 삽입된 콘텐츠는 종종 코드 블록 내에서 자신의 스타일 규칙을 구술한다.
    해결방안
    <head> 요소안에 CSS를 링크하고, @import의 사용을 자제해야 한다.
    자바스크립트의 선언순서, 위치를 body 안 밑으로
    FOUC를 유발하는 구역을 숨겼다가 문서의 스타일이나 스크립트가 모두 적용되면 보여준다.
    프린트 관련 css등 지금 당장 렌더링에 필요 없는 css는 lazy loading처리 한다.

● memory leak
    사용되지 않는 객체가 남아있는것
    해결 방법
        - 사용하지 않은 객체, 변수는 모두 null 로 초기화 하십시오.
        - 이벤트 핸들러를 필요없을때는 항상 언바인딩 해준다.
        - 이벤트 연결시 함수를 클로저 유효범위가 적은곳에서 선언한후 연결한다.
        - DOM 을 동적으로 생성했다면, 불필요한 객체, 속성(값)을 DOM 에 삽입하지 마십시오.
        - 만약, DOM 에 특정 속성, 객체를 삽입했다면 DOM 해제 시 모두 제거하십시오.
    타임라인 도구 사용법
    https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?hl=ko

● 가비지 콜렉션
    표시하고-쓸기(Mark-and-sweep) 알고리즘
    주기적으로 가비지 콜렉터는 roots(전역객체)로 부터 시작하여 roots가 참조하는 오브젝트들,
    roots가 참조하는 오브젝트가 참조하는 오브젝트쭉 확인하고 접근할수없거나 순환참조만이 유일할때
    메모리에서 비워진다.

● script cross domain
    서로 다른 도메인에서 자바스크립트로 접근하려 했을 때 혹은 다른 서버에 Ajax통신의 결과를 받을 때 보안상 접근을 거부합니다.(동일 출처 정책)
    해결법
        - sub도메인이 다를경우 : document.domain.com을 바꿔준다.
        - 서버측에서 처리 내부 URI에서 서버 코딩으로 처리
        - jsonp를 사용한다.

● 웹 워커
    javascript 멀티쓰래드 가능하게 해주는 api
    교착상태
    한 스레드가 자원을 무한정 점유하고 있어 다른 쓰레드가 무한정 대기하는 상황
    상호배제, 점유대기, 비선점, 순환대기

● sandbox
    컴퓨터 보안을 위환 환경
    브라우저가 접근할 수 있는 자원들을 제한하는 대신, 제한되지 않은 자원들에 대해서만은 자유롭게 접근하고 조작
    파일쓰기 등 사용자 컴퓨터 기능 사용 못함

● 페이지 이동
    location.replace("이동할 주소");
    를 상용할경우에는 현재페이지가 히스토리에 안남고 이동함

● 크롬에서의 팝업
    window.open("www.naver.com","hi","width=200,height=100")
    파업이름과 주소값을 정확히 적어주어야 팝업으로 만들어짐 안그러면 탭으로 활성화됨

● proxy 서버
    필요한 정보를 미리 캐쉬해 두었다가 요청이 오면 전달하여
    데이터 베이스 접근을 줄일수 있다.

● 문서 쿼크 모드
    웹 브라우저는 두 가지 렌더링 모드를 지니고 있는데 쿼크모드(Quirks mode)와 표준모드(Standard mode)이다
    DTD를 보고 판단
    이전 세대의 브라우저에 맞는 비표준적 방법의 CSS를 적용한다.
    ex) 박스모델은 ie는 비표준으로 달라지지만 다른 브라우저는 표준과 맞춘다.(border-box랑 똑같이 동작)

● documentFragment
    메모리상에서만 존재하는 빈 문서 템플릿
    이 노드를 사용하여 문서를 조작하고 메인 문서에 삽입하게 되면 flow를 줄일수 있다.

● dom box model
    블락형태의 dom요소 레이아웃에 대한 정의
    margin,border,padding,content(width,height) 이루어져 있다.
    쿼크모드에서는 width, height안에 패딩과 보더가 포함되어 있다.

● 객체 크기 위치 정확히
    http://appletree.or.kr/blog/notes/dom%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%81%AC%EA%B8%B0%EC%99%80-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%9C%84%EC%B9%98%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4/

● css의 cascading (style sheet)
    DOM 문서 트리에서 상위 앨리먼트에 있는 스타일 속성이 그 하위 앨리먼트로 흘려내려서 상속되기 때문입니다.
    무조건 적인건 아님

● 키이벤트 동작 순서와 차이
    전처리 - 눌러진키가 특수키인지 아닌지를 판별하는등 내장 기능
    keydown 발생 -> keypress 발생 -> keyup 발생
    특수키를 누를때 keydown발생하지만 keypress는 문자입력만 동작한다. (그리고 한글은 동작 안함)

● 이벤트 여러개 등록했을때 동작순서
    html이나 자바스크립트 속성으로 선언된 것이 가장 먼저 실행
    addEventListner는 선언된 순서되로 실행
    attatchEvent 실행된 순서 보장 못함

● 스크립트 실행중에 이벤트가 동작할것인가
    스크립트가 돌아갈때는 이벤트가 동작하지않고 스택에 저장되었다가
    브라우저가 무휴 상태가 되면 그때 실행된다.

● jsonp callback
    url?callback=foo 처럼 url뒤에 함수이름을 붙여주면 콜백함수를 알아서 실행해 준다.

● html이나 body 어디에 min-width값을 줘야하나
    html에 주면된다.

● 자동으로 생긴 스크롤 값에 대한 접근 및 수정
    appleWebkit을 사용한 브라운(크롬,사파리,오페라)는 로딩후에 setTimeout에 0을 줘서 스크롤값을 변경해야 한다.

● 직열화
    객체를 전송가능한 형태로 만드느것을 직렬화 하라고 한다.
    selrialize 같은 것들

● javascript serialize
    폼요소를 가지고 uri로 전송가능한 쿼리 스트링을 만들어냄
    a=1&b=2&c=3&d=4&e=5

● less, sass
    less
        - nodejs 기반
        - 변수선언 @
        - 전역/지역 변수 구분 있음
        - 이스케이프 기능
    sass
        -ruby기반
        -변수선언 $
        - 전역/지역 변수 구분 없음
        - 선택자 상속
        - 제어문 가능
    공통
        - 계산과 함수
        - 중첩규칙( 상위 태그 안에 하위태그 스타일 입력)
        - mixin이라고 하고 이미 정의된 css를 함수처럼 사용

● api 정의
     운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다

● encodeUricomponent
    get방식으로 데이터를 전달하려고 할때 한글 및 특수문자가 깨지기 때문에

● 엔디언 방식
    엔디언(Endianness)은 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

● blob
    “대용량 바이너리 객체”쯤으로 해석할 수 있다
     slice를 통해 Blob 데이터를 구성하고 Blob URL을 통해 데이터를 가져온다.

● 무간섭 DOM 스크립팅
    html 문서내에 javascript코드가 없게 하는것

● argumnets.caller와 callee 사용하지 말아야 하는 이유
    신뢰할만한 이식성을 보장하지 않는 비표준이다.

● void 연산자
    void 연산자는 주어진 식(expression)을 실행하고, undefined 반환합니다.

● AMD, Template Language, MVC/MVVM 등의 패턴, CSS pre-processor
     - Template Language : anugular, prototype 등의 라이브러리
     - CSS pre-processor : sass,less
     - MVC/MVVM
        MVC (Model - View - Controller)
        MVVM (Model - View - ViewModel) - 사용자 인풋에 대한 동작이 더 잘 구현
        http://secretroute.tistory.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4MVC-MVP-and-MVVM
        http://programmingsummaries.tistory.com/142

● 웹폰트 로딩 문제
    - 스타일되지 않은 텍스트가 번쩍거릴 수 있다.(flash of unstyled text:FOUT)
    - GZip을 사용하든지, 헤더 최상단에 배치해 최대한 빠르게 로딩
    - 바로 글꼴 로딩중에 본문이 안나울경우 : 구글 API를 webfont load를 이용하여 웹폰트가 로드된후 폰트를 지정한다.


● HTTP, HTTPS 차이점
    HTTPS : 웹서버와의 주고 받는 정보를 암호화, 접속이 끊기게 되면 다시 처음부터 시작해야 하는 불편함이 따른다.
            암호화 복호화에 따른 부하

● utf8 utf 16
    utf8은 최소 1바이트, 영어권에 유리,용량이 작음
    utf16은 최소 16바이트

● 쓰레드, 프로세스에 대한 설명
    프로세스 : 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.
    프로세스 내에서 실행되는 흐름의 단위를 말한다.

● 다형성, 인터페이스, 추상 클래스, 가상메소드
    다형성 : 자바에서 부모객체 타입 변수에 자식객체를 담을 수 있는것
    추상클래스 : 하나이상의 추상 메서드를 가진 객체
    추상 메서드 : 내용이 없는 비어 잇는 메소드(abstract)
    인터페이스 : 서로다른 클래스들의 연결장치(협업시에 좋음 규칙이 정해져 있어서) implement로 구현한다.
    가상메소드 : 추상메서드와 동일하지만 내용을 삽입할수 있다.(virtual)

● 참조무결성, 트랜잭션(커밋,롤백)
    참조무결성 :  참조 무결성은 기본키에 대한 외부키의 논리적 종속성입니다. 기본키로 있는 테이블에서 삭제될경우 외래키로 쓰고있는곳에도 적용이 되야 한다.
    트랜잭션 : 데이터베이스 등의 시스템에서 사용되는 쪼갤 수 없는 업무처리의 단위

● OOP의 의미와 장단점
    추상화(Abstraction) 하고, 캡슐화화는 과정
    장점
        기능과 의미별로 캡슐화하여 구분하여서 재사용성이 좋다.
    단점
        설계가 오래 걸린다.

● 자바스크립트 라이브러리 종류
    http://okjsp.tistory.com/1165644297

● 프로세스, 스레드, 메모리, vector/list
    vector : 개체들을 연속적인 메모리 공간에 저장한다.(연결리스트) 끝에서만 삽입/삭제빠름
    list : 노드에 앞뒤노드의 연결주소를 같이 가지고 있다. 어느 위치에서든 삽입/삭제가 빠른다.

● Http 통신시 Post/Get 방식의 차이점
    get은 url방식이라 데이터가 노출되고 많은양의 데이터를 보낼수 없다.
    post 데이터 노출 없이 많은양의 데이터를 보낼수 있다.

● Library와 DLL
    표준화 할 수 있는 함수들을 하나에 모아서 공유하면서 쓰기 위해 만들어진게 라이브러리
    DLL은 소스에 직접 라이브러리 함수를 삽입하지 않고 필요할때만 가져다가 쓰는것


● rtp와 rtcp 차이점
    rtp : 비디오 오디오 데이터를 전송하기 위한 프로토콜
    rtcp : 전송상태 감시 및 세션관련 정보 전송을 위한 프로토콜

● ECMAScript5
    - Object.defineProperties통한 속성 추가 및 속성 옵션(쓰기, 변경,열거, get,set)
    - Object.create를 통한 객체 상속
    - Object.preventExtensions(객체명) : 객체의 속성 추가를 제한합니다
    - Object.seal(객체명) : 객체의 속성 삭제를 제한합니다.
    - Object.keys(객체명) : 객체의 반복 순환 가능한 속성명으로 배열을 만듭니다.(enumerable: true인 것)
    - Object.getOwnPropertyNames(객체명) : 객체의 모든 속성명으로 배열을 만듭니다.
    - Object.getOwnPropertyDescriptor(객체명, 속성명) : 특정 속성의 옵션 객체를 추출합니다.

● reactjs 원리
     - React.js는 정말 UI 컴포넌트만 지원합니다.
     - 자바스크립트 내에 DOM Tree와 같은 구조체를 VIRTUAL DOM으로 갖고 있습니다. 변경이 필요한 최소한의 요소만 실제 DOM에 반영해 속도가 빠릅니다.
     - React.js는 단방향 데이터 흐름을 지향합니다.
     - JSX : XML 비슷한 언어
     - React와 Redux : http://d2.naver.com/helloworld/1848131

● 몽키패칭
    코어 스크립트를 prototype 확장하는것

● ddos
    서비스 거부 공격, 좀비피씨등을 통해 수많은 접속 시도를 만들어 다른 이용자가 정상적으로 서비스 이용을 하지 못하게 하거나, 서버의 TCP 연결을 바닥내는 등의 공격이 이 범위에 포함된다\

● 알고리즘 그리기
    http://www.haangul.com/bbs/board.php?bo_table=flow_chart&wr_id=2

● AMP
    - AMP Cache를 사용하면 웹 페이지의 모든 JavaScript 파일과 이미지 파일을 같은 출처(origin)에서 로딩할 수 있으며 HTTP 2.0의 장점을 최대한 살릴 수 있다.

● tcp 3-way hand shaking?
    - http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake

str.charAt(0);            // returns H

str.charCodeAt(0);         // returns 72

문제
    - 1000* 1000 셀에 한가지 셀에 1000가지 색이 들어 갈때 필요한 메모리의 양
    시간 복잡도 , 소트
    1차에서 간단한 알고리즘에 대해 물었습니다. 기억에 남는건 1~1000의 숫자중 중복 가능하게 1000개의 숫자를 뽑았을때, 이들 중 중간값을 묻는 문제였습니다.
    카운팅 소트
    - 문자열(String)과 관련된 간단한 코딩
    - 숫자 표시 문자열 -> 숫자 변환 알고리즘 작성
    중복되지 않는 수를 배열에서 출력하는 코드를 작성하라

    이진 트리에서 max depth를 구하는 코드를 작성하라

    100! = 100 * 99 * ... * 2 * 1 = xx…x00..0 = xx…x * 10^n
    이 때 n의 값은?
    나: (잠시 고민 후)곱해서 10이 만들어져야 0의 자리수가 늘어나니까 곱해지는 5의 개수랑 2의 개수를 세면 될 것 같다.
    1부터 100까지 5의 배수는 5, 10, 15, … 이니까 5*1, 5*2, …, 5*20이 되고, 20개가 있다.
    마찬가지로 2의 배수는 50개가 될 것이다.
    그러므로 0의 개수는 20개이다.

    면접관: 뭔가 빠뜨린게 있는 것 같다. 다시 한 번 생각해봐라.

    나: (열심히 생각 후) 아 그런데 단순히 2와 5의 배수 개수로 따지면 안되겠다. 5의 제곱의 경우에는 5를 두번 곱하는 것과 같은 효과가 있다. 25의 배수는 4개가 있으니까... 답은 24개이다.

    소팅 알고리즘 슈도코드로 구현할 때 변수를 사용하지 않고 해보라고 한 것...

    손코딩 문자열로된 숫자를 int형으로 바꾸는 로직

    개발 중에 일어났던 이슈와 해결 방법은 했던 방법으로 대답



인성질문
● 왜 이직을 하려고 하는가,
    전 회사는 연예인 위주의 회사였기 때문에 개발자 처우가 별로 좋지 않았습니다.
    그래서 저는 개발자 처우가 좋은 네이버에 지원하게 되었습니다.

● 왜 해당 언어를 사용하는가,
    처음에 학교에서 배운 딱딱한 프로그래밍만을 알고 있다가.
    사용자와 가장 가깝게 소통할수 있는 언어라고 생각하여 매력을 느끼게 되었습니다.
    자바스크립트는 컴파일이 필요없어 빠르게 코드의 결과를 확인할 수 있었고요.
    html/css를 통해 디자인시안을 브라우저에 하나하나씩 퍼즐맞추는 구현해내는 느낌도 좋았습니다.
    그리고 nodejs등 javascript가 전 분야에 걸쳐 사용될수 있도록 개발되고 있다는 애기도 있습니다.
    javascript 전문가가 되고 싶다는 생각이 들게 하였다.

● 이용하거나 알고있는 네이버 서비스에 대해 말해보시오,
    평소에 네이버를 자주 사용한는데요.
    기본적으로 검색, 실시간검색, 메일기능을 사용하고요.
    블로그를 만들어본 경험도 있습니다.
    그리고 지식쇼핑도 많이 이용하고요. 지도 서비스도 많이 이용하고 있습니다.

● 어떤 것을 개발하고 싶은가?
    저는 사용자가 재미있게 상호작용할수 있는 UI를 개발하고 싶습니다.
    애니메이션과 canvas, svg를 사용해 사용자 경험을 증대시키고 싶습니다.
    그리고 네이버에서 일하게 될때 제일 기대 되는 것은 저는 지금까지 혼자 프론트 개발자로써 일을 해왔는데요.
    이번에 같은 업무 사람들과 협의하면서 일할수 있는것이 많이 기대 됩니다.

● 10년후 나의 모습(이를 위해 어떤 노력을 해왔고, 어떤 노력을 해갈것인가)
    처음에는 일단 영어를 아주 잘하게 될 것 같습니다.
    제가 해외여행을 좋아하고요 이번에 여행에서 너무 부족함을 느끼고 필요성을 느껴서요. 그리고 제 업무에서도 영어를 잘해야 새로운 정보나 api문서들을 빠르게 습득할수 있으니
    입사후에 영어공부를 마음을 단단히 먹고 독하게 해볼생각입니다.
    그리고 네이버에 아이디어 대회가 있던데요.
    저는 제가 센스도 있고 아이디어도 괜찮다고 생각합니다.
    제가 만든 아이디어로 네이버에서 큰 역할을 할수 있는 사람이 되고 싶습니다.

● 왜 네이버에 오려고하고 이곳에 니가 원하던 모습이 존재하지 않으면 어떻게 할 것인가?
    네이버는 제가 이일을 처음시작할때 부터 제일 오고 싶었던 회사입니다.
    저는 제 업무에 대해 인정 받으면서 일하고 싶습니다. 우리나라에서 개발자 처우가 가장 좋은 네이버가 그래서 목표입니다.

    어느 회사도 모든걸 다 만족시켜줄순 없다고 생각합니다.
    자기의 행복과 만족은 자기 스스로가 찾아가는 것이라고 생각합니다.

● 작업 방식은 만들고 나서 돌아가는지 확인하는가? 아니면 설계 후에 만들기 시작하는가?
    큰 뼈대의 알고리즘은 먼저 구상한후
    코딩을 시작하고
    나머지 작은 기능들은 만들면서 추가합니다.

● 최근 읽은 개발관련 문서가 있나요?
    이번에 면접준비하면서 많은 책을 봣는데요.
    자바스크립트 완벽가이드
    effective 자바스크립트
    네이버에서 만든
    웹접근성, 웹 최적화(자바스크립트 성능이야기)가 있습니다.

● 오픈소스 경험 있는가?
    개인적으로 만든 hashtag editor가 있습니다. 구글 플러스 커뮤니티에 올려고 놓았고 사람들과 피드백을 주고 받을 계횝니다.

● 부서 선택 이유, 다른 부서 배치는 괜찮은지
    네이버는 제가 꼭 일하고 싶은 회사였고,
    해당부서의 공고를 보고  제 능력에 합당하다고 생각해서 바로 지원하게 되었습니다.
    마음을 열어 놓겠지만 정확한 업무 내용을 봐야 결정할수 있을거 같습니다.

● 좋아하는 과목, 좋아하는 기술?!
    저는 javascript를 좋아합니다. 그래서 지금 nodejs랑ractjs,react-native, mongodb를 활용한 앱을 개발중에 있습니다.

● 자기소개
    안녕하세요. 저는 4년차가 되어가는 프로트엔드 개발자 손일권이라고 합니다.
    와우플레이, sm엔터테이먼트에서 메인 프론트엔드 개발자로 일하였습니다.
    프톤트는 웹서비스의 얼굴이라고 생각합니다.
    사용자와 가장 가까운 곳에서 사용자와 서로 상호작용하는 프로그램을 만드는일에 매력을 느꼇고, 개발자로써 자부심을 가지게 되었습니다.
    그래서 신기술을 공부 하고 영어공부도 틈틈히 하며 조금씩 제자신을 발전시켜나가고 있습니다.
    회사에 입사하게 되면 제자리에 머물르지 않고 회사와 저의 발전을 위해 노력할것을 약속드립니다.
    감사합니다.
